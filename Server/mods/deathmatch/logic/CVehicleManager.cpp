/*****************************************************************************
 *
 *  PROJECT:     Multi Theft Auto v1.0
 *  LICENSE:     See LICENSE in the top level directory
 *  FILE:        mods/deathmatch/logic/CVehicleManager.cpp
 *  PURPOSE:     Vehicle entity manager class
 *
 *  Multi Theft Auto is available from http://www.multitheftauto.com/
 *
 *****************************************************************************/

#include "StdInc.h"

// List over all vehicles with their special attributes
#define VEHICLE_HAS_TURRENT             0x001UL //1
#define VEHICLE_HAS_SIRENS              0x002UL //2
#define VEHICLE_HAS_LANDING_GEARS       0x004UL //4
#define VEHICLE_HAS_ADJUSTABLE_PROPERTY 0x008UL //8
#define VEHICLE_HAS_SMOKE_TRAIL         0x010UL //16
#define VEHICLE_HAS_TAXI_LIGHTS         0x020UL //32
#define VEHICLE_HAS_SEARCH_LIGHT        0x040UL //64

// Generated by MTA10\utils\gentable\gentable_vehattr.cpp
//static const SFixedArray<unsigned long, 212> g_ulVehicleAttributes = {
//    {0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0,  0,  0, 0, 2, 0,  0, 0, 32, 0, 0,  2, 0,            // 400-424
//     0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  32, 0, 0, 0, 0,  8, 0, 0,  0, 0,  0, 0,            // 425-449
//     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0,  0, 0, 0,  0, 0,  0, 0,            // 450-474
//     0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0,  0,  0, 2, 0, 0,  0, 0, 0,  0, 64, 0, 0,            // 475-499
//     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 0, 0, 0, 0,  0, 4, 12, 0, 0,  2, 8,            // 500-524
//     8, 0, 0, 2, 0, 8, 8, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0,  0, 2, 0,  0, 0,  0, 0,            // 525-549
//     0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0,  0, 0, 0,  0, 0,  0, 0,            // 550-574
//     0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 12, 0, 0, 0,  2, 2,  2, 2,            // 575-599
//     0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

CVehicleManager::CVehicleManager()
{
}

CVehicleManager::~CVehicleManager()
{
    DeleteAll();
}

CVehicle* CVehicleManager::Create(CElement* pParent, unsigned short usModel, unsigned char ucVariant, unsigned char ucVariant2)
{
    CVehicle* const pVehicle = new CVehicle(this, pParent, usModel, ucVariant, ucVariant2);

    if (pVehicle->GetID() == INVALID_ELEMENT_ID)
    {
        delete pVehicle;
        return nullptr;
    }

    return pVehicle;
}

CVehicle* CVehicleManager::CreateFromXML(CElement* pParent, CXMLNode& Node, CEvents* pEvents)
{
    RandomizeRandomSeed();
    CVehicle* pVehicle = new CVehicle(this, pParent, 400, 254, 254);

    if (pVehicle->GetID() == INVALID_ELEMENT_ID || !pVehicle->LoadFromCustomData(pEvents, Node))
    {
        delete pVehicle;
        return nullptr;
    }

    return pVehicle;
}

void CVehicleManager::DeleteAll()
{
    // Delete all items
    DeletePointersAndClearList(m_List);
}

void CVehicleManager::RemoveFromList(CVehicle* pVehicle)
{
    m_List.remove(pVehicle);
}

bool CVehicleManager::Exists(CVehicle* pVehicle)
{
    return ListContains(m_List, pVehicle);
}

bool CVehicleManager::IsValidModel(unsigned int uiVehicleModel)
{
    if (g_pGame->GetModelManager()->GetVehicleModel(uiVehicleModel))
        return true;

    return false;
}

eVehicleType CVehicleManager::GetVehicleType(unsigned short usModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(usModel);
    if (pModel)
        return pModel->GetVehicleType();

    return eVehicleType::NONE;
}

bool CVehicleManager::IsValidUpgrade(unsigned short usUpgrade)
{
    return (usUpgrade >= 1000 && usUpgrade <= 1193);
}

unsigned int CVehicleManager::GetMaxPassengers(unsigned int uiVehicleModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(uiVehicleModel);
    if (pModel)
    {
        return pModel->GetPassengesCount();
    }

    return 0xFF;
}

void CVehicleManager::GetRandomVariation(unsigned short usModel, unsigned char& ucVariant, unsigned char& ucVariant2)
{
    RandomizeRandomSeed();
    ucVariant = 255;
    ucVariant2 = 255;
    // Valid model?
    char cVariants = g_pGame->GetModelManager()->GetVehicleModel(usModel)->GetVariantsCount();
    if (IsValidModel(usModel) && cVariants != 255)
    {
        // caddy || cropduster
        if (usModel == 457 || usModel == 512)
        {
            // 255, 0, 1, 2
            ucVariant = (rand() % 4) - 1;

            // 3, 4, 5
            ucVariant2 = (rand() % 3);
            ucVariant2 += 3;
            return;
        }
        // Slamvan
        else if (usModel == 535)
        {
            // Slamvan has steering wheel "extras" we want one of those so default cannot be an option.
            ucVariant = (rand() % (cVariants + 1));
            return;
        }
        // NRG 500 || BF400
        else if (usModel == 522 || usModel == 581)
        {
            // e.g. 581 ( BF400 )
            // first 3 properties are Exhaust
            // last 2 are fairings.

            // 255, 0, 1, 2
            ucVariant = (rand() % 4) - 1;

            // 3, 4
            ucVariant2 = (rand() % 2);
            ucVariant2 += 3;
            return;
        }
        // e.g. ( rand () % ( 5 + 2 ) ) - 1
        // Can generate 6 then minus 1 = 5
        // Can generate 0 then minus 1 = -1 (255) (default model with nothing)
        ucVariant = (rand() % (cVariants + 2)) - 1;
    }
}

bool CVehicleManager::HasTurret(unsigned int uiModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(uiModel);
    if (pModel)
        return pModel->GetAttributes() & VEHICLE_HAS_TURRENT;

    return false;
}

bool CVehicleManager::HasSirens(unsigned int uiModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(uiModel);
    if (pModel)
        return pModel->GetAttributes() & VEHICLE_HAS_SIRENS;

    return false;
}

bool CVehicleManager::HasTaxiLight(unsigned int uiModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(uiModel);
    if (pModel)
        return pModel->GetAttributes() & VEHICLE_HAS_TAXI_LIGHTS;

    return false;
}

bool CVehicleManager::HasLandingGears(unsigned int uiModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(uiModel);
    if (pModel)
        return pModel->GetAttributes() & VEHICLE_HAS_LANDING_GEARS;

    return false;
}

bool CVehicleManager::HasAdjustableProperty(unsigned int uiModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(uiModel);
    if (pModel)
        return pModel->GetAttributes() & VEHICLE_HAS_ADJUSTABLE_PROPERTY;

    return false;
}

bool CVehicleManager::HasSmokeTrail(unsigned int uiModel)
{
    CModelVehicle* pModel = g_pGame->GetModelManager()->GetVehicleModel(uiModel);
    if (pModel)
        return pModel->GetAttributes() & VEHICLE_HAS_SMOKE_TRAIL;

    return false;
}

bool CVehicleManager::HasDamageModel(unsigned short usModel)
{
    return HasDamageModel(GetVehicleType(usModel));
}

bool CVehicleManager::HasDamageModel(eVehicleType Type)
{
    switch (Type)
    {
        case eVehicleType::TRAILER:
        case eVehicleType::MONSTERTRUCK:
        case eVehicleType::QUADBIKE:
        case eVehicleType::HELI:
        case eVehicleType::PLANE:
        case eVehicleType::CAR:
            return true;
        default:
            return false;
    }
}

bool CVehicleManager::HasDoors(unsigned short usModel)
{
    bool bHasDoors = false;

    if (HasDamageModel(usModel) == true)
    {
        switch (usModel)
        {
            case VT_BFINJECT:
            case VT_RCBANDIT:
            case VT_CADDY:
            case VT_RCRAIDER:
            case VT_BAGGAGE:
            case VT_DOZER:
            case VT_FORKLIFT:
            case VT_TRACTOR:
            case VT_RCTIGER:
            case VT_BANDITO:
            case VT_KART:
            case VT_MOWER:
            case VT_RCCAM:
            case VT_RCGOBLIN:
                break;
            default:
                bHasDoors = true;
        }
    }

    return bHasDoors;
}

CVehicleColor CVehicleManager::GetRandomColor(unsigned short usModel)
{
    return m_ColorManager.GetRandomColor(usModel);
}

void CVehicleManager::GetVehiclesOfType(unsigned int uiModel, lua_State* luaVM)
{
    assert(luaVM);

    // Add all the matching vehicles to the table
    unsigned int              uiIndex = 0;
    list<CVehicle*>::iterator iter = m_List.begin();
    for (; iter != m_List.end(); ++iter)
    {
        if ((*iter)->GetModel() == uiModel)
        {
            // Add it to the table
            lua_pushnumber(luaVM, ++uiIndex);
            lua_pushelement(luaVM, *iter);
            lua_settable(luaVM, -3);
        }
    }
}
